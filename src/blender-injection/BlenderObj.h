#pragma once

// define memory layouts of Blender

struct Context
{
    int thread;

    struct
    {
        void* manager;
        void* window;
        void* workspace;
        void* screen;
        void* area;
        void* region;
        void* menu;
        void* gizmo_group;
        void* store;

        const char* operator_poll_msg;

        struct PollMsgDyn_Params
        {
            char* (*get_fn)(Context*, void*);
            char* (*free_fn)(Context*, void*);
            void* user_data;
        } operator_poll_msg_dyn_params;
    } wm;

    struct
    {
        void* main;
        void* scene;
        int recursion;
        bool py_init;
        void* py_context;
        void* py_context_orig;
    } data;
};

using eWM_DragFlags = enum eWM_DragFlags
{
    WM_DRAG_NOP = 0,
    WM_DRAG_FREE_DATA = 1,
};

using ListBase = struct ListBase
{
    void *first, *last;
};

using wmDragActiveDropState = struct wmDragActiveDropState
{
    /** Informs which dropbox is activated with the drag item.
     * When this value changes, the #draw_activate and #draw_deactivate dropbox callbacks are
     * triggered.
     */
    struct wmDropBox* active_dropbox;

    /** If `active_dropbox` is set, the area it successfully polled in. To restore the context of it
     * as needed. */
    struct ScrArea* area_from;
    /** If `active_dropbox` is set, the region it successfully polled in. To restore the context of
     * it as needed. */
    struct ARegion* region_from;

    /** If `active_dropbox` is set, additional context provided by the active (i.e. hovered) button.
     * Activated before context sensitive operations (polling, drawing, dropping). */
    struct bContextStore* ui_context;

    /** Text to show when a dropbox poll succeeds (so the dropbox itself is available) but the
     * operator poll fails. Typically the message the operator set with
     * CTX_wm_operator_poll_msg_set(). */
    const char* disabled_info;
    bool free_disabled_info;
};

using wmDrag = struct wmDrag
{
    struct wmDrag *next, *prev;

    int icon;
    /** See 'WM_DRAG_' defines above. */
    int type;
    void* poin;
    char path[1024]; /* FILE_MAX */
    double value;

    /** If no icon but imbuf should be drawn around cursor. */
    struct ImBuf* imb;
    float imbuf_scale;

    wmDragActiveDropState drop_state;

    eWM_DragFlags flags;

    /** List of wmDragIDs, all are guaranteed to have the same ID type. */
    ListBase ids;
    /** List of `wmDragAssetListItem`s. */
    ListBase asset_items;
};

using wmTabletData = struct wmTabletData
{
    /** 0=EVT_TABLET_NONE, 1=EVT_TABLET_STYLUS, 2=EVT_TABLET_ERASER. */
    int active;
    /** range 0.0 (not touching) to 1.0 (full pressure). */
    float pressure;
    /** range 0.0 (upright) to 1.0 (tilted fully against the tablet surface). */
    float x_tilt;
    /** as above. */
    float y_tilt;
    /** Interpret mouse motion as absolute as typical for tablets. */
    char is_motion_absolute;
};

using eWM_EventFlag = enum eWM_EventFlag
{
    /**
     * True if the operating system inverted the delta x/y values and resulting
     * `prev_xy` values, for natural scroll direction.
     * For absolute scroll direction, the delta must be negated again.
     */
    WM_EVENT_SCROLL_INVERT = (1 << 0),
    /**
     * Generated by auto-repeat, note that this must only ever be set for keyboard events
     * where `ISKEYBOARD(event->type) == true`.
     *
     * See #KMI_REPEAT_IGNORE for details on how key-map handling uses this.
     */
    WM_EVENT_IS_REPEAT = (1 << 1),
    /**
      * Mouse-move events may have this flag set to force creating a click-drag event
      * even when the threshold has not been met.
      */
    WM_EVENT_FORCE_DRAG_THRESHOLD = (1 << 2),
};

using wmEvent = struct wmEvent
{
    struct wmEvent *next, *prev;

    /** Event code itself (short, is also in key-map). */
    short type;
    /** Press, release, scroll-value. */
    short val;
    /** Mouse pointer position, screen coord. */
    int xy[2];
    /** Region relative mouse position (name convention before Blender 2.5). */
    int mval[2];
    /**
     * A single UTF8 encoded character.
     * #BLI_str_utf8_size() must _always_ return a valid value,
     * check when assigning so we don't need to check on every access after.
     */
    char utf8_buf[6];

    /** Modifier states: #KM_SHIFT, #KM_CTRL, #KM_ALT & #KM_OSKEY. */
    uint8_t modifier;

    /** The direction (for #KM_CLICK_DRAG events only). */
    int8_t direction;

    /**
     * Raw-key modifier (allow using any key as a modifier).
     * Compatible with values in `type`.
     */
    short keymodifier;

    /** Tablet info, available for mouse move and button events. */
    wmTabletData tablet;

    eWM_EventFlag flag;

    /* Custom data. */

    /** Custom data type, stylus, 6-DOF, see `wm_event_types.h`. */
    short custom;
    short customdata_free;
    /** Ascii, unicode, mouse-coords, angles, vectors, NDOF data, drag-drop info. */
    void* customdata;

    /* Previous State. */

    /** The previous value of `type`. */
    short prev_type;
    /** The previous value of `val`. */
    short prev_val;
    /**
     * The previous value of #wmEvent.xy,
     * Unlike other previous state variables, this is set on any mouse motion.
     * Use `prev_press_*` for the value at time of pressing.
     */
    int prev_xy[2];

    /* Previous Press State (when `val == KM_PRESS`). */

    /** The `type` at the point of the press action. */
    short prev_press_type;
    /**
     * The location when the key is pressed.
     * used to enforce drag threshold & calculate the `direction`.
     */
    int prev_press_xy[2];
    /** The `modifier` at the point of the press action. */
    uint8_t prev_press_modifier;
    /** The `keymodifier` at the point of the press action. */
    short prev_press_keymodifier;
    /**
     * The time when the key is pressed, see #PIL_check_seconds_timer.
     * Used to detect double-click events.
     */
    double prev_press_time;
};
